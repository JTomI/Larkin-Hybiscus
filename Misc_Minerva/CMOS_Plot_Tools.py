import pandas as pd
import h5py
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import os
import imageio
from datetime import datetime
from tqdm import tqdm


class CPT(object):
	"""Class intented to be a very general toolset for handling the Spectroscopy Data generated by Minerva/Antelope."""
	def __init__(self,data_path=None):
		self.path = data_path
		self.hf = h5py.File(self.path, 'r')
		self.items = list(self.hf.items())
		self.list_impedance = self.get_list(filterstring='impedance')
		self.grp_data = self.hf.get(self.list_impedance[0])
		self.phase_types = list(self.grp_data.keys()) # Check how many image phases there are in impedance
		print("Impedance Image Phase Types in the Dataset: ",self.phase_types)
		print("Number of images in dataset with {} phase(s): ".format(len(self.phase_types)),len(self.items))

	def get_data(self, index=None):
		grp_data = self.hf.get(self.list_impedance[index])
		phase_images = [] 
		for phase in self.phase_types:
			phase_images.append(grp_data[phase][:])
		return phase_images

	def get_list(self, filterstring=None):
		grp_list = []
		for i in range(len(self.items)):
			grp = self.items[i]
			grp_list.append(grp[0])
			if filterstring is not None:
				grp_list = [x for x in grp_list if filterstring in x]
		return grp_list

	def edge_finder1d(self, array1d=None):
		"""Finds the two endpoints of a 1D array with boolean entries."""
		lims = []
		for i in range(len(array1d)): #Find left limit
			if array1d[i] == True:
				lims.append(i)
				break
		for i in range(len(array1d)): #Find Right limit
			if array1d[len(array1d)-1-i] == True:
				lims.append(len(array1d)-1-i)
				break
		return lims

	# def get_croplims(self, index=None, thresh=.00005):
	# 	"""Finds the uFluidic chamber edges in an impedance image using a chosen threshold value, and returns an image cropped to those edges."""
	# 	phase_images=self.get_data(index=index)
	# 	mean_phase = np.zeros_like(phase_images[0])
	# 	for phase in phase_images: #Average the image values across all the phases in the dataset for better contrast edge-finding.
	# 		mean_phase += phase/len(phase_images)
	# 	mean_x,mean_y = np.mean(mean_phase,axis=0),np.mean(mean_phase,axis=1) #Average across x and y respectively to make clear edges.
	# 	xcrop1d,ycrop1d = (mean_x>thresh),(mean_y>thresh) # isolate the region above the threshold, which is the region to crop to. 
	# 	[self.xlim1,self.xlim2],[self.ylim1,self.ylim2] = self.edge_finder1d(xcrop1d),self.edge_finder1d(ycrop1d) #find the edges of the crop.
	# 	return self.xlim1,self.xlim2,self.ylim1,self.ylim2

	# def get_crop(self, index=None):
	# 	"""Get a cropped version of the phase images at position 'index', having used a reference image to determine the crop boundaries."""
	# 	# Uses whatever xy lims are currently set to in self.
	# 	phase_images=self.get_data(index=index)
	# 	for i in range(len(phase_images)):
	# 		phase_images[i]=phase_images[i][self.ylim1:self.ylim2,self.xlim1:self.xlim2]
	# 	return phase_images

	def process_image(self,index=None, Nstd=5, crop=True,xlims=[0,256],ylims=[0,512]):
		"""Returns a smoothed image processed from a 2-phase dataset by removing the stepped effect from the 8 Minerva channel groups.
		Outliers above standard deviation of 'Nstd' removed."""
		[phase1,phase2]=self.get_data(index=index)
		normrows = range(ylims[0],ylims[1]); # Normalize over rows that are within the microfluidic;
		phase = (phase1+phase2)/2
		# Perform Normalization per channel
		ch0mean = np.mean(phase[normrows, xlims[0]:((xlims[0]//32)+1)*32]) # find mean for leftmost channel that is in microfluidic
		# Handle channels that are not partially covered in 256 pixel direction. 
		for ch in range(((xlims[0]//32)+1),(xlims[1]//32)):
			phase[normrows, ch*32:(ch+1)*32] = phase[normrows, ch*32:(ch+1)*32] / np.mean(phase[normrows, ch*32:(ch+1)*32])*ch0mean

		# Handle leftmost channel, partially covered. 
		phase[normrows, xlims[0]:((xlims[0]//32)+1)*32] = phase[normrows,xlims[0]:((xlims[0]//32)+1)*32]/np.mean(phase[normrows,xlims[0]:((xlims[0]//32)+1)*32])*ch0mean
		# Handle rightmost channel, partially covered.
		phase[normrows, (xlims[1]//32)*32:xlims[1]] = phase[normrows,(xlims[1]//32)*32:xlims[1]]/np.mean(phase[normrows, (xlims[1]//32)*32:xlims[1]])*ch0mean
		# Remove outliers above chosen Nstd
		phase = np.abs(phase)
		med=np.median(np.ravel(phase))
		std=np.std(np.ravel(phase))
		phase[np.abs(phase-med)>(Nstd*std)] = med
		vmin=np.mean(phase[normrows,:])-2*Nstd*np.std(phase[normrows,:])
		vmax=np.mean(phase[normrows,:])+Nstd*np.std(phase[normrows,:])
		if crop:
			return phase[ylims[0]:ylims[1],xlims[0]:xlims[1]],vmin,vmax
		else:
			return phase,vmin,vmax

	def make_video(self,index_rng=[0,0],fps=30,cmap='Spectral',crop=True,Nstd=5,figsize=(16,12),step=1,xlims=[0,256],ylims=[0,512]):
		 """Returns .gif of Impedance Time Series Data"""
		 self.frames = []
		 for i in tqdm(range(index_rng[0],index_rng[1],step),desc="Processing Images"):
			  fig, ax_main = plt.subplots(figsize=figsize)
			  image, vmin, vmax = self.process_image(index=i,crop=crop,xlims=xlims,ylims=ylims,Nstd=Nstd)
			  im = ax_main.imshow(np.flip(np.transpose(image),axis=1),vmin=vmin,vmax=vmax,cmap=cmap)
			  ax_main.axis('off')
			  fig.canvas.draw();		 # draw the canvas, cache the renderer
			  im = np.frombuffer(fig.canvas.tostring_rgb(), dtype='uint8')
			  im = im.reshape(fig.canvas.get_width_height()[::-1] + (3,))
			  self.frames.append(im)
			  plt.close('all')
		 print("Saving...")
		 imageio.mimsave(self.path.replace(".h5",".gif"), self.frames, fps=fps)
		 print("Saved to", self.path.replace(".h5",".gif"))
