import pandas as pd
import h5py
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import os
import imageio
from tqdm import tqdm


class CPT(object):
	"""Class intented to be a very general toolset for handling the Spectroscopy Data generated by Minerva/Antelope."""
	def __init__(self,data_path=None,Luna=False,Luna_Threshold=.00005):
		self.path = data_path
		self.hf = h5py.File(self.path, 'r')
		self.items = list(self.hf.items())
		self.list_impedance = self.Get_List(filterstring='impedance')
		# Check how many image phases there are in impedance
		grp_data = self.hf.get(self.list_impedance[0])
		self.phase_list = list(grp_data.keys())
		print("Impedance Image Phases: ",self.phase_list)
		print("Number of 2 phase images in dataset: ",len(self.items))
		if Luna:
			self.xlim1,self.xlim2,self.xlim3,self.xlim4 = self.Get_Crop_Lims(ref_index=0,thresh=.00005)
		self.frames = []
		self.images = []


	def Get_Data(self,index=None):
		grp_data = self.hf.get(self.list_impedance[index])
		phases = []
		for phase in self.phase_list:
			phases.append(grp_data[phase][:])
		return phases

	def Get_List(self,filterstring=None,sortby=None):
		grp_list = []
		for i in range(len(self.items)):
			grp = self.items[i]
			grp_list.append(grp[0])
		if filterstring is not None:
			grp_list = [x for x in grp_list if filterstring in x]
		if sortby is 'time':
			grp_list = sorted(grp_list,key=lambda x: Get_Time(self.path,x))
		return grp_list

	def Edge_Finder1D(self,Array1D=None):
	    """Finds the two endpoints of a 1D array with boolean entries."""
	    lims = []
	    flipper = True
	    for i in range(len(Array1D)):
	        if Array1D[i] == flipper:
	            lims.append(i)
	            flipper=not flipper
	    return lims

	def Get_Crop_Lims(self,ref_index=0,thresh=.00005):
	    """Find the uFluidic chamber edges in an impedance image using a chosen threshold values, and returns an image cropped to those edges."""
	    [phase1,phase2]=self.Get_Data(ref_index=0)
	    avphase = (phase1+phase1)/2
	    av_xlinecut,av_ylinecut = np.mean(avphase,axis=0),np.mean(avphase,axis=1)
	    xcrop1D,ycrop1D = (av_xlinecut>thresh),(av_ylinecut>thresh)
	    ([xlim1,xlim2],[ylim1,ylim2])= self.Edge_Finder1D(xcrop1D),self.Edge_Finder1D(ycrop1D)
	    return xlim1,xlim2,ylim1,ylim2

	# def Get_All(self):
	# 	self.images = []
	# 	for i in tqdm(range(0,len(self.list_impedance),1),desc="Decoding Images"):
	# 		image = self.Get_Data(self.list_impedance[i])
	# 		self.images.append(image)
	# 	return self.images

	# def Composite_Image(self,image_1, image_2):
	# 	image_3 = np.zeros_like(image_1)
	# 	image_3[0:8,:] =  image_1[0:8,:]
	# 	for k in range(0,511,64):
	# 		mean_1 = np.mean(image_1[(k+8):(k+24)])
	# 		mean_2 = np.mean(image_2[(k+8):(k+24)])
	# 		image_1[(k+0):,:] = image_1[(k+0):,:] - (mean_1-mean_2)

	# 		mean_1 = np.mean(image_1[(k+40):(k+56)])
	# 		mean_2 = np.mean(image_2[(k+40):(k+56)])
	# 		image_2[(k+32):,:] = image_2[(k+32):,:] - (mean_2-mean_1)

	# 		image_3[(k+8):(k+56),:] =  image_1[(k+8):(k+56),:]
	# 		image_3[(k+56):(k+72),:] =  image_2[(k+56):(k+72),:]
	# 	return image_
	# def Get_Image(self,i,display=False,norm_display=False,composite=False,cmap='Spectral',figsize=(16,12)):
	#     """Returns data from a single frame, and plots values as a raw image, 
	#     an image with median-normalization, or a composite image."""
	#     # tx = Decode.Get_Time(self.path,self.list_impedance[i])
	#     image1 = self.Get_Data(self.list_impedance[i])
	#     if composite:
	#         image2 = self.Get_Data(self.list_impedance[i+1])
	#         image = self.Composite_Image(image1,image2)
	#     else:
	#         image=image1
	#     if display:
	#         fig, ax_main = plt.subplots(figsize=figsize)
	#         if norm_display:
	#             im = ax_main.imshow(np.transpose(image)-np.median(image),vmin=-0.5,vmax=1.5,cmap=cmap)
	#         else:
	#             im = ax_main.imshow(np.transpose(image),cmap=cmap)
	#         fig.colorbar(im,ax=ax_main)
	#         ax_main.set_title(str(i) + '   ' + self.list_impedance[i] + ' time elapsed ' + str(tx-self.t0))
	#         plt.show()
	#     return image

	# def Make_Video(self,fps=30,norm_display=False,composite=False,contrast_fix=False,cmap='Spectral',figsize=(16,12),step=1):
	#     """Returns .gif of Impedance Time Series Data"""
	#     self.frames = []
	#     for i in tqdm(range(0,len(self.list_impedance),step),desc="Decoding Images"):
	#         fig, ax_main = plt.subplots(figsize=figsize)
	#         image1 = self.Get_Data(self.list_impedance[i])
	#         # tx = self.Get_Time(self.path,self.list_impedance[i])
	#         if composite: 
	#             if i!=(len(self.list_impedance)-1):
	#                 image2 = self.Get_Data(self.list_impedance[i+1])
	#                 image = self.Composite_Image(image1,image2)
	#             else:
	#                 image=image1  
	#         else:
	#             image=image1     
	#         if contrast_fix:
	#             if norm_display:
	#                 im = ax_main.imshow(np.transpose(image)-np.median(image),vmin=-.75,vmax=.75,cmap=cmap)
	#             else:
	#                 im = ax_main.imshow(np.transpose(image),vmin=12,vmax=13.5,cmap=cmap)
	#         else:
	#             if norm_display:
	#                 im = ax_main.imshow(np.transpose(image)-np.median(image),cmap=cmap)
	#             else:
	#                 im = ax_main.imshow(np.transpose(image),cmap=cmap)    
	#         fig.colorbar(im,ax=ax_main)
	#         # ax_main.set_title(str(i) + '   ' + self.list_impedance[i] + ' time elapsed ' + str(tx-self.t0))
	#         fig.canvas.draw();       # draw the canvas, cache the renderer
	#         im = np.frombuffer(fig.canvas.tostring_rgb(), dtype='uint8')
	#         im  = im.reshape(fig.canvas.get_width_height()[::-1] + (3,))
	#         self.frames.append(im)
	#         plt.close('all')
	#     print("Saving...")
	#     imageio.mimsave(self.path.replace(".h5",".gif"), self.frames, fps=fps)
	#     print("Saved to", self.path.replace(".h5",".gif"))
