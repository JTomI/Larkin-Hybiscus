import pandas as pd
import h5py
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import os
import imageio
from tqdm import tqdm


class CPT(object):
	"""Class intented to be a very general toolset for handling the Spectroscopy Data generated by Minerva/Antelope."""
	def __init__(self,data_path=None):
		self.path = data_path
		self.hf = h5py.File(self.path, 'r')
		self.items = list(self.hf.items())
		self.list_impedance = self.Get_List(filterstring='impedance')
		self.grp_data = self.hf.get(self.list_impedance[0])
		self.phase_types = list(self.grp_data.keys()) # Check how many image phases there are in impedance
		print("Impedance Image Phase Types in the Dataset: ",self.phase_types)
		print("Number of images in dataset with {} phase(s): ".format(len(self.phase_types)),len(self.items))
		self.xlim1 = None; self.xlim2 = None; self.ylim1 = None; self.ylim2 = None;

		self.frames = []
		self.images = []

	def Get_Data(self,index=None):
		grp_data = self.hf.get(self.list_impedance[index])
		phase_images = [] 
		for phase in self.phase_types:
			phase_images.append(grp_data[phase][:])
		return phase_images

	def Get_List(self,filterstring=None,sortby=None):
		grp_list = []
		for i in range(len(self.items)):
			grp = self.items[i]
			grp_list.append(grp[0])
		if filterstring is not None:
			grp_list = [x for x in grp_list if filterstring in x]
		if sortby is 'time':
			grp_list = sorted(grp_list,key=lambda x: Get_Time(self.path,x))
		return grp_list

	def Edge_Finder1D(self,Array1D=None):
	    """Finds the two endpoints of a 1D array with boolean entries."""
	    lims = []
	    flipper = True
	    for i in range(len(Array1D)): #Find left limit
	        if Array1D[i] == flipper:
	            lims.append(i)
	            break
	    for i in range(len(Array1D)): #Find Right limit
	        if Array1D[len(Array1D)-1-i] == flipper:
	            lims.append(len(Array1D)-1-i)
	            break
	    return lims

	def Get_Crop_Lims(self,index=None,thresh=.00005):
	    """Finds the uFluidic chamber edges in an impedance image using a chosen threshold value, and returns an image cropped to those edges."""
	    phase_images=self.Get_Data(index=index)
	    mean_phase = np.zeros_like(phase_images[0])
	    for phase in phase_images: #Average the image values across all the phases in the dataset for better contrast edge-finding.
	    	mean_phase += phase/len(phase_images)
	    mean_x,mean_y = np.mean(mean_phase,axis=0),np.mean(mean_phase,axis=1) #Average across x and y respectively to make clear edges.
	    xcrop1D,ycrop1D = (mean_x>thresh),(mean_y>thresh) # isolate the region above the threshold, which is the region to crop to. 
	    [self.xlim1,self.xlim2],[self.ylim1,self.ylim2]= self.Edge_Finder1D(xcrop1D),self.Edge_Finder1D(ycrop1D) #find the edges of the crop.
	    return self.xlim1,self.xlim2,self.ylim1,self.ylim2
	
	def Get_Cropped_Data(self,index=None):
		"""Get a cropped version of the phase images at index, using the image at ref_index to determine the crop boundaries."""
		phase_images=self.Get_Data(index=index)
		if self.xlim1 == None:
			print("Define crop region with function Get_Crop_Lims")
		else:
			for i in range(len(phase_images)):
				phase_images[i]=phase_images[i][self.ylim1:self.ylim2,self.xlim1:self.xlim2]
			return phase_images

	# def Composite_Image(self,image_1, image_2):
	# 	image_3 = np.zeros_like(image_1)
	# 	image_3[0:8,:] =  image_1[0:8,:]
	# 	for k in range(0,511,64):
	# 		mean_1 = np.mean(image_1[(k+8):(k+24)])
	# 		mean_2 = np.mean(image_2[(k+8):(k+24)])
	# 		image_1[(k+0):,:] = image_1[(k+0):,:] - (mean_1-mean_2)

	# 		mean_1 = np.mean(image_1[(k+40):(k+56)])
	# 		mean_2 = np.mean(image_2[(k+40):(k+56)])
	# 		image_2[(k+32):,:] = image_2[(k+32):,:] - (mean_2-mean_1)

	# 		image_3[(k+8):(k+56),:] =  image_1[(k+8):(k+56),:]
	# 		image_3[(k+56):(k+72),:] =  image_2[(k+56):(k+72),:]
	# 	return image_

	# def Make_Video(self,fps=30,norm_display=False,composite=False,contrast_fix=False,cmap='Spectral',figsize=(16,12),step=1):
	#     """Returns .gif of Impedance Time Series Data"""
	#     self.frames = []
	#     for i in tqdm(range(0,len(self.list_impedance),step),desc="Decoding Images"):
	#         fig, ax_main = plt.subplots(figsize=figsize)
	#         image1 = self.Get_Data(self.list_impedance[i])
	#         # tx = self.Get_Time(self.path,self.list_impedance[i])
	#         if composite: 
	#             if i!=(len(self.list_impedance)-1):
	#                 image2 = self.Get_Data(self.list_impedance[i+1])
	#                 image = self.Composite_Image(image1,image2)
	#             else:
	#                 image=image1  
	#         else:
	#             image=image1     
	#         if contrast_fix:
	#             if norm_display:
	#                 im = ax_main.imshow(np.transpose(image)-np.median(image),vmin=-.75,vmax=.75,cmap=cmap)
	#             else:
	#                 im = ax_main.imshow(np.transpose(image),vmin=12,vmax=13.5,cmap=cmap)
	#         else:
	#             if norm_display:
	#                 im = ax_main.imshow(np.transpose(image)-np.median(image),cmap=cmap)
	#             else:
	#                 im = ax_main.imshow(np.transpose(image),cmap=cmap)    
	#         fig.colorbar(im,ax=ax_main)
	#         # ax_main.set_title(str(i) + '   ' + self.list_impedance[i] + ' time elapsed ' + str(tx-self.t0))
	#         fig.canvas.draw();       # draw the canvas, cache the renderer
	#         im = np.frombuffer(fig.canvas.tostring_rgb(), dtype='uint8')
	#         im  = im.reshape(fig.canvas.get_width_height()[::-1] + (3,))
	#         self.frames.append(im)
	#         plt.close('all')
	#     print("Saving...")
	#     imageio.mimsave(self.path.replace(".h5",".gif"), self.frames, fps=fps)
	#     print("Saved to", self.path.replace(".h5",".gif"))
